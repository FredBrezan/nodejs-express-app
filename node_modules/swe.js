/*#################################################################################################*/

var _gscope = global

var util = require('util')
var path = require('path')

/*#################################################################################################
 * The 'swe' namespace groups all the methods of the this framework.
 *#################################################################################################*/

var swe = {
    
  //===============================================================================================
  // Class Framework
  //===============================================================================================
  
  
  //***********************************************************************************************
  // defineClass(className, parentClass)
  //   Define a new Class object. A class contructor of name 'className' is created, and its 
  //   prototype is chained to the 'parentClass' if it is defined and different than 'Object'.
  //   Basically, for Javascript, a class is actually made of a constructor function to
  //   which a prototype object is linked. The constructor sets the member variables, while the
  //   prototype contains the member methods. Here, we link that to a third kind of objects of
  //   the custom type 'Class', which we use later to control what is implemented in the new
  //   class, and its link to the prototype chain.
  defineClass: function (className, parentClass) {
      
    // if 'className' is already defined, return its Class instance (__class__ attribute) */
    if (_gscope[className] != undefined) return _gscope[className].prototype.__class__;
      
    // In the object constructor function defined below, 'this' is the newly created instance 
    // (by the 'new' operator.) 'this.__class__' refers to the constructor's prototype '__class__' 
    // property which is a 'new Class()' object. */
    var theClassCtor = function () { 
        if (this.__class__ === undefined) throw "Use 'new' to create an instance of the class";
        this.__class__.init(this, arguments) };
    theClassCtor.__name__ = className;
    _gscope[className] = theClassCtor;
    //console.log('[defineClass()] classCtor=%s parentClass=%s', theClassCtor, parentClass);
    if (parentClass != undefined) { 
      if (typeof(parentClass) == 'string') parentClass = _gscope[parentClass]; 
      if (parentClass != Object) theClassCtor.prototype = new parentClass(swe.defineClass); 
    }
    theClassCtor.prototype.constructor = theClassCtor;
    theClassCtor.prototype.toString = function() { return '[object ' + className + ']'; };
    theClassCtor.prototype.__class__ = new Class(null, theClassCtor);
    //console.log(util.inspect(theClassCtor.prototype.__class__, {showHidden:true}))
    return theClassCtor.prototype.__class__;
  },
    

  //===============================================================================================
  // Debug Framework
  //===============================================================================================
  

  //***********************************************************************************************
  // Local debug string
  _dbglog: '\n',
    
  //***********************************************************************************************
  // getPropDescr(obj)
  //   Return an array of all the properties of 'obj' with their types.
  getPropDescr: function (obj) {
    var r = [];
    for (p in obj) {
      var g = obj.__lookupGetter__(p);
      var s = obj.__lookupSetter__(p);
      var t = typeof(obj[p]);
      if (g || s) t = (g ? (s ? 'get/set' : 'get') : 'set')
      r.push(p + ':' + t);
    }
    return r;
  },
    
  //***********************************************************************************************
  // getArrayDescr(arrayObj)
  //   Return a string representation of an array's content. Elements that are arrays themselves
  //   are not analyzed and shows up as '{Array}' object type.
  getArrayDescr: function (arrayObj) {
    var s = [];
    for (var i = 0; i < arrayObj.length; i++) s.push(this.getObjDescr(arrayObj[i], false))
    return '[' + s.join(',') + ']';
  },
    
  //***********************************************************************************************
  // getObjDescr(obj [, deep=true])
  //   Return a pretty string representation of an object. If the object is of type array (or 
  //   array-like), the content is shown as well unless the parameter 'deep' is present and false. 
  getObjDescr: function (obj) {
    var deep = (arguments.length > 1 ? arguments[1] : true);
    switch (typeof(obj)) {
    case 'string':
      return '"' + obj + '"';
    case 'function':
      if (obj.name) return 'function ' + obj.name + '()';
      var f = obj.toString()
      return f.substr(0, f.indexOf('(')) + '()';
    case 'object':
      // if 'obj' has 'callee' and 'length' properties, it is assumed to be an array-like 'arguments' object.
      var objTypeName = obj.constructor.name;
      var isArray = (objTypeName == 'Array') || (obj.callee && obj.length);
      return (isArray && deep) ? this.getArrayDescr(obj) :  '{' + objTypeName + '}' ;
    default:
      return obj; // undefined, boolean, number, ...
    }
  },
    
  //***********************************************************************************************
  // dbg(arg1, arg2, ...)
  //   Append each arg to the local debug string. If an argument is of type 'function' or 'object'
  //   get its pretty representation beforehands. The content of the local debug string can be 
  //   retrieved with the accessor 'swe.dbglog'
  dbg: function(/* arg1, arg2, ... */) {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      var typ = typeof(arg); // 'undefined', 'boolean', 'number', 'string', 'function', 'object', '<custom>'
      if      (typ == 'string')    this._dbglog += arg
      else if (typ == 'object')    this._dbglog += this.getObjDescr(arg)
      else if (typ == 'function')  this._dbglog += this.getObjDescr(arg)
      else if (typ == 'undefined') this._dbglog += '{undefined}'
      else                         this._dbglog += arg.toString()
    }
  },
    
  //***********************************************************************************************
  // Clear the local debug string
  dbgclr: function() {
    this._dbglog = '\n';
  },
    
  //***********************************************************************************************
  //get dbglog () { return this._dbglog; },
}

/*#################################################################################################
 * The public 'Class' type, used to define a new class and its implementation
 *#################################################################################################*/


//*************************************************************************************************
// Class(className, classArg)
//   Class type factory. the given 'className' argument (as a string) will be used afterwards with
//   the 'new' operator to create className's instances. 'classArg' is the name (or class object) 
//   of a parent class. 'Class()' is invoked in two situations:
//   - Publicly, when defining a new class: Class('Foo').implementation = { ... }; 
//   - Internaly, when instanciating a Class object (meta-class) from 'swe.defineClass()'
//   In the 1st case, we call swe.defineClass() to add the new class type to the global scope, 
//   while in the 2nd case, a Class instance is created to represent the className type.
function Class(className, classArg) {
  // global context:   classArg=parentClass, this=_gscope
  // instance context: classArg=classCtor,   this=classInstance
  // if 'this == _gscope', it means that Class() is called in the global context
  // in this case, we are not defining a new class, but building its implementation
  var isGlobalScope = (typeof className == "string");
  //console.log('[Class()] context=%s className=%s classArg=%s', isGlobalScope ? 'global' : 'object', className, classArg);
  if (isGlobalScope) return swe.defineClass(className, classArg);
  // In the Class() contructor context, init this new Class() instance (describes a new object type)
  className = classArg.__name__
  //console.log('[Class()] context=object className='+className, ' classArg='+classArg, '\n');
  this._className = className;
  this._classCtor = classArg;
}

Class.prototype =
{
  //***********************************************************************************************
  // nice representation of the object instance.
  toString: function() { return '{Class:' + this._className + '}'; },
  
  //***********************************************************************************************
  // init() is a proxy method called by the object's constructor. The actual object's constructor 
  // parameters 'this' and 'arguments' are passed as function arguments 'theObj' and 'ctorArgs'. 
  // We check whether the contructor is called in the prototype context (i.e. setting the parent 
  // class of a new class) or in the instance construction context.
  init: function(theObj, ctorArgs) {
    // check the first arguments to prevent calling __init__() when 'new' is used to define a prototype
    // Indeed, for a child class of a given parent class, the child class's prototype is set to
    // a new instance of the parent class so that it inherits all the member variables and methods
    // via the prototype chain. In this case, we don't to call the instance's __init__ function.
    ////console.log('[Class.init()]', 'this._className='+this._className, 'theObj=', theObj);
    ////console.log('ctorArgs.callee='+getObjInfo(ctorArgs.callee), 'ctorArgs[0]='+getObjInfo(ctorArgs[0]),'\n');
    if (ctorArgs[0] != swe.defineClass) {
      var theObjCtor = ctorArgs.callee;
      var theObjProto = theObjCtor.prototype;
      ////if (this._className == theObjCtor.name) console.log('[Class()] new ', this._className, '(...)\n');
      ////console.log('[Class:', this._className, ':init()] ctor=', theObjCtor, '; __init__(', ctorArgs, ')\n')
      if (theObjProto.__init__) theObjProto.__init__.apply(theObj, ctorArgs);
    }
  },

  //***********************************************************************************************
  // Extend the class prototype with the attributes of a given objects. Used by the 'implementation'
  // setter below.
  extend: function (otherObject) {
    // This method extend the managed class prototypes with the properties of 'otherObject', taking
    // care of properly handling the getters and setters.
    var thisClassProto = this._classCtor.prototype;
    for (var propName in otherObject) {
      var propGetter = otherObject.__lookupGetter__(propName);
      var propSetter = otherObject.__lookupSetter__(propName);
      if (propGetter || propSetter) {
        if (propGetter) thisClassProto.__defineGetter__(propName, propGetter);
        if (propSetter) thisClassProto.__defineSetter__(propName, propSetter);
      }
      else {
        var propType = typeof(otherObject[propName]);
        if (propType == 'function') {
          // function properties are directly assigned to the object's prototype.
          thisClassProto[propName] = otherObject[propName];
        }
        else {
          // For class variables (static variables), we replace the property itself by a pair of
          // getter/setter so that the property is always accessed at the level where the prototype
          // defined it. It is done this way because otherwise as soon as an instance or any 
          // descendant object would have set a value with this property name, a new local property 
          // with the same name would have been created, thus hiding the original property.
          // The name of the property to store the value is mangled, and the original name is used 
          // for the getter/setter.
          staticVarName = '$static$' + this._className + '$' + propName;
          thisClassProto[staticVarName] = otherObject[propName];
          thisClassProto.__defineGetter__(propName, function() { return thisClassProto[staticVarName]; }); 
          thisClassProto.__defineSetter__(propName, function(v) { thisClassProto[staticVarName] = v; });
        }
      }
    }
    return thisClassProto;
  },

  //***********************************************************************************************
  set implementation(attributes) { this.extend(attributes); },
}

//#################################################################################################

function checkModule(modulePath) {
    console.log('[SWE] checkModule %s (%s)', modulePath, path.resolve(modulePath));
    modulePath = path.resolve(modulePath)
    var moduleImplPath = require.resolve(modulePath);
    var loadedModule = require.cache[moduleImplPath];
    console.log('[SWE] require .resolve=%s .cache=%s', moduleImplPath, loadedModule)
    if (loadedModule === undefined) {
        console.log('[SWE] load module')
        var moduleImpl = require(modulePath);
        moduleImpl.__path = moduleImplPath;
        return moduleImpl;
    } else {
        console.log('[SWE] delete and reload module')
        delete require.cache[moduleImplPath];
        var newModuleImpl = require(modulePath);
        for (i in newModuleImpl) {
            console.log('reinit', i)
            loadedModule[i] = newModuleImpl[i]
        }
        require.cache[moduleImplPath] = loadedModule
        return loadedModule;
    }
}

//#################################################################################################

module.exports.Class        = Class
module.exports.checkModule  = checkModule
module.exports.loadModule   = checkModule

//#################################################################################################
/*
Class('SweAppLoader').implementation = {

    __init__: function() {
        this._dfd = $.Deferred();
        this._inproc = 0;
        this._syncproc = function () {}
        this.data = {};
    },
    
    get inproc()  { return this._inproc; },
    set inproc(v) { this._inproc = v; },

    _done: function () {
        this.inproc -= 1;
        if (this.inproc == 0) this._syncproc(this.data);
    },

    run: function(syncproc) {
        this._syncproc = syncproc;
        this._dfd.resolveWith(this);    
    },
    
    loadText: function(path, keyname) {
        var that = this;
        this.inproc += 1;
        $.get(path).done(function(data, status, jqxhr) {
            that.data[keyname] = data;
            that._dfd.done(that._done);
        });
    },
    
    loadXML: function(path, keyname) {
        var that = this;
        this.inproc += 1;
        $.get(path).done(function(data, status, jqxhr) {
            that.data[keyname] = data;
            that._dfd.done(that._done);
        }).fail(function(jqXHR, textStatus, errorThrown) {
            console.log('LoadXML: Error', jqXHR, textStatus, errorThrown);
        });
    },
    
    loadCSS: function(path) {
        var that = this;
        this.inproc += 1;
        $.get(path, function(css) {
            $('<style type="text/css"></style>').html(css).appendTo("head");
        }).done(function() { that._dfd.done(that._done); });
    },
    
    loadJS: function(path) {
        var that = this;
        this.inproc += 1;
        $.getScript(path, function(script, status, jqxhr) { 
              console.log('jq.getScript: '+ status + '(' + jqxhr.status + ') :' + path); 
        }).fail(function() { console.log('jq.getScript: failed: ' + path); })
          .done(function() { that._dfd.done(that._done); });        
    },
};
*/
//#################################################################################################
 
/*
Class('Foo').implementation = {

  StaticVal: 'class string',
  
  __init__: function(v) {
    this._val = v;
  },
  
  get val()  { return this._val; },
  set val(v) { this._val = v; }, 

};

foo1 = new Foo(71);
foo2 = new Foo(42);

console.log("instance attr: foo1.val=%d; foo2.val=%d", foo1.val, foo2.val);
foo1.val = 17;
foo2.val = 24;
console.log("instance attr: foo1.val=%d; foo2.val=%d", foo1.val, foo2.val);
console.log("class attr   : foo1.StaticVal='%s'; foo2.StaticVal='%s'", foo1.StaticVal, foo2.StaticVal);
foo1.StaticVal = "new string";
console.log("class attr   : foo1.StaticVal='%s'; foo2.StaticVal='%s'", foo1.StaticVal, foo2.StaticVal);
*/

//#################################################################################################
